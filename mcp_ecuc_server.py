#!/usr/bin/env python3

"""
MCP ECUC Server - Python Implementation with FastMCP

An MCP (Model Context Protocol) server that provides AI assistants with access to 
ECUC (ECU Configuration) data extraction functionality using FastMCP.
"""

import asyncio
import os
import subprocess
import tempfile
from pathlib import Path
from typing import Any, Dict, List, Optional

from fastmcp import FastMCP


class EcucMcpServer:
    """MCP Server for ECUC data extraction"""
    
    def __init__(self):
        self.server = Server("mcp-ecuc-server")
        self.ecuc_project_path = os.getenv("ECUC_PROJECT_PATH", "../mcp-ecuc")
        self.java_extractor_class = "EcucExtractor"
        
        # Register handlers
        self._register_tools()
        self._register_resources()
    
    async def execute_java_extractor(self, command: str) -> str:
        """
        Execute Java ECUC extractor with a custom Java snippet
        
        Args:
            command: The command/operation to execute
            
        Returns:
            The output from the Java extractor
            
        Raises:
            Exception: If the Java process fails
        """
        try:
            java_code_injection = self._get_java_code_injection(command)
            
            # Create temporary Java content
            temp_java_content = f"""
import model.EcucModel;
import pdur.PdurExtractorUtil;

public class EcucExtractor {{
    
    public static void main(String[] args) throws Exception {{
        
        EcucModel ecucDataModel = new EcucModel();
        ecucDataModel.initialize();

        // Print the model to verify
        System.out.println(ecucDataModel);

        // The following part shall be generated by Copilot based on the instructions in COPILOT_INSTRUCTIONS.md
        // Copilot: start writing your code here
        
        {java_code_injection}

        // Copilot: stop writing your code here
    }}
}}
            """
            
            # Use the portable compilation script
            script_path = Path(self.ecuc_project_path) / "compile_and_run_portable.sh"
            
            # Set up environment with temporary Java code
            env = os.environ.copy()
            env["TEMP_JAVA_CODE"] = temp_java_content
            
            # Execute the script
            process = await asyncio.create_subprocess_exec(
                'sh', str(script_path),
                cwd=self.ecuc_project_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                env=env
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                return stdout.decode('utf-8')
            else:
                raise Exception(f"Java process failed with code {process.returncode}: {stderr.decode('utf-8')}")
                
        except Exception as e:
            raise Exception(f"Error executing Java extractor: {str(e)}")
    
    def _get_java_code_injection(self, command: str) -> str:
        """
        Generate Java code injection based on the command
        
        Args:
            command: The command to generate code for
            
        Returns:
            Java code snippet to inject
        """
        if command == "getAllComIPdus":
            return """
        // Get all ComIPdus from Com model
        java.util.ArrayList<com.ComIPdu> allComIPdus = ecucDataModel.getCom().getComIPdus();
        
        System.out.println("All ComIPdus from Com model:");
        System.out.println("Total ComIPdus count: " + allComIPdus.size());
        
        for (com.ComIPdu comIPdu : allComIPdus) {
            System.out.println("- " + comIPdu.getName() + 
                             " (Direction: " + comIPdu.getPduDirection() + 
                             ", PDU: " + comIPdu.getEcucPduRef().getPduName() + ")");
        }
            """
        
        elif command == "getPduRTotalCount":
            return """
        // Get total PduR count using utility method
        pdur.PdurExtractorUtil pdurUtil = new pdur.PdurExtractorUtil();
        int totalPduCount = pdur.PdurExtractorUtil.getTotalPduCount(ecucDataModel.getPduR());
        System.out.println("Total PduR PDU count: " + totalPduCount);
            """
        
        elif command == "getCanIfChannels":
            return """
        // Get all CanIf channels
        java.util.Map<String, can.CanIfChannel> channels = ecucDataModel.getCanIf().getCanIfChannels();
        System.out.println("CanIf Channels:");
        for (String channelName : channels.keySet()) {
            can.CanIfChannel channel = channels.get(channelName);
            System.out.println("- Channel: " + channel.getCanIfChannelName());
            System.out.println("  PDUs: " + channel.getCanIfPdus().size());
        }
            """
        
        elif command.startswith("findPduRSrcPdu:"):
            pdu_name = command[len("findPduRSrcPdu:"):]
            return f"""
        // Find PduR source PDU by name
        pdur.PduRSrcPdu targetSrcPdu = pdur.PdurExtractorUtil.findSrcPduByName(
            ecucDataModel.getPduR().getPduRSrcPdus(), 
            "{pdu_name}"
        );
        
        if (targetSrcPdu != null) {{
            System.out.println("Found {pdu_name}:");
            System.out.println("  PDU Name: " + targetSrcPdu.getPduName());
            System.out.println("  Referenced EcucPdu Name: " + targetSrcPdu.getEcucPduRef().getPduName());
            System.out.println("  Referenced EcucPdu ID: " + targetSrcPdu.getEcucPduRef().getPduId());
            System.out.println("  Referenced EcucPdu Length: " + targetSrcPdu.getEcucPduRef().getPduLength() + " bytes");
        }} else {{
            System.out.println("{pdu_name} not found!");
        }}
            """
        
        elif command.startswith("custom:"):
            return command[len("custom:"):]
        
        else:
            raise ValueError(f"Unknown command: {command}")
    
    def _register_tools(self):
        """Register MCP tools"""
        
        @self.server.list_tools()
        async def handle_list_tools() -> List[Tool]:
            """List available tools"""
            return [
                Tool(
                    name="get_all_com_ipdus",
                    description="Get all ComIPdus from the Com model with their details",
                    inputSchema={
                        "type": "object",
                        "properties": {},
                    },
                ),
                Tool(
                    name="find_pdur_src_pdu_by_name",
                    description="Find a PduR source PDU by name",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "pduName": {
                                "type": "string",
                                "description": "Name of the PduR source PDU to find",
                            }
                        },
                        "required": ["pduName"],
                    },
                ),
                Tool(
                    name="get_pdur_total_count",
                    description="Get total PDU count from PduR module",
                    inputSchema={
                        "type": "object",
                        "properties": {},
                    },
                ),
                Tool(
                    name="get_canif_channels",
                    description="Get all CanIf channels and their configurations",
                    inputSchema={
                        "type": "object",
                        "properties": {},
                    },
                ),
                Tool(
                    name="extract_custom_data",
                    description="Execute custom ECUC data extraction code",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "extractionCode": {
                                "type": "string",
                                "description": "Custom Java code snippet to execute for data extraction",
                            }
                        },
                        "required": ["extractionCode"],
                    },
                ),
            ]
        
        @self.server.call_tool()
        async def handle_call_tool(name: str, arguments: Dict[str, Any]) -> List[types.TextContent | types.ImageContent | types.EmbeddedResource]:
            """Handle tool calls"""
            try:
                if name == "get_all_com_ipdus":
                    result = await self.execute_java_extractor("getAllComIPdus")
                    return [types.TextContent(type="text", text=result)]
                
                elif name == "find_pdur_src_pdu_by_name":
                    pdu_name = arguments.get("pduName")
                    if not pdu_name:
                        raise ValueError("pduName is required")
                    result = await self.execute_java_extractor(f"findPduRSrcPdu:{pdu_name}")
                    return [types.TextContent(type="text", text=result)]
                
                elif name == "get_pdur_total_count":
                    result = await self.execute_java_extractor("getPduRTotalCount")
                    return [types.TextContent(type="text", text=result)]
                
                elif name == "get_canif_channels":
                    result = await self.execute_java_extractor("getCanIfChannels")
                    return [types.TextContent(type="text", text=result)]
                
                elif name == "extract_custom_data":
                    extraction_code = arguments.get("extractionCode")
                    if not extraction_code:
                        raise ValueError("extractionCode is required")
                    result = await self.execute_java_extractor(f"custom:{extraction_code}")
                    return [types.TextContent(type="text", text=result)]
                
                else:
                    raise ValueError(f"Unknown tool: {name}")
                    
            except Exception as e:
                error_msg = f"Error executing tool '{name}': {str(e)}"
                return [types.TextContent(type="text", text=error_msg)]
    
    def _register_resources(self):
        """Register MCP resources"""
        
        @self.server.list_resources()
        async def handle_list_resources() -> List[Resource]:
            """List available resources"""
            return [
                Resource(
                    uri="ecuc://model/overview",
                    name="ECUC Model Overview",
                    description="Overview of the ECUC model structure and available modules",
                    mimeType="text/plain",
                )
            ]
        
        @self.server.read_resource()
        async def handle_read_resource(uri: str) -> str:
            """Read resource content"""
            if uri == "ecuc://model/overview":
                overview = """
ECUC Model Overview
==================

The ECUC (ECU Configuration) model contains the following main modules:

1. Com Module:
   - Contains ComIPdus (Communication Interface PDUs)
   - Handles message transmission and reception
   - Direction: Rx (Receive) and Tx (Transmit)

2. CanIf Module:
   - CAN Interface module with channels
   - Contains CanIfPduCfg configurations
   - Manages CAN channel configurations

3. PduR Module:
   - PDU Router module
   - Contains source and destination PDUs
   - Manages routing paths between PDUs

Available Tools:
- get_all_com_ipdus: Retrieve all ComIPdus
- find_pdur_src_pdu_by_name: Find specific PduR source PDU
- get_pdur_total_count: Get total PDU count
- get_canif_channels: Get CanIf channel information
- extract_custom_data: Execute custom extraction code

Usage:
The server integrates with existing Java ECUC extraction utilities
and provides a standardized MCP interface for AI assistants.
                """
                return overview.strip()
            else:
                raise ValueError(f"Unknown resource: {uri}")


async def main():
    """Main function to run the MCP server"""
    server_instance = EcucMcpServer()
    
    # Run the server using stdio transport
    async with stdio_server() as (read_stream, write_stream):
        await server_instance.server.run(
            read_stream, write_stream, server_instance.server.create_initialization_options()
        )


if __name__ == "__main__":
    print("ECUC MCP Server (Python) running on stdio", file=os.sys.stderr)
    asyncio.run(main())
